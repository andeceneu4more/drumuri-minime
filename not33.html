<!DOCTYPE HTML>
<html>
	<head>
	<style type="text/css">
	#apDiv1 {
	position: absolute;
	width: 760px;
	height: 265px;
	z-index: 1;
	left: 62px;
	top: 106px;
}
    #apDiv2 {
	position: absolute;
	width: 530px;
	height: 225px;
	z-index: 2;
	left: 97px;
	top: 488px;
}
	#apDiv2 ol li {
	list-style-position: inside;
	position: relative;
}
	#apDiv2 ol {
		margin-top:0px;
}
    #apDiv3 {
	position: absolute;
	width: 719px;
	height: 115px;
	z-index: 3;
	left: 84px;
	top: 733px;
}
    #apDiv4 {
	position: absolute;
	width: 766px;
	height: 720px;
	z-index: 4;
	left: 58px;
	top: 1051px;
}
    #apDiv5 {
	position: absolute;
	width: 257px;
	height: 108px;
	z-index: 5;
	left: 277px;
	top: 1822px;
}
    #apDiv6 {
	position: absolute;
	width: 717px;
	height: 83px;
	z-index: 6;
	left: 89px;
	top: 1935px;
	font-family: calibri;
}
    #apDiv7 {
	position: absolute;
	width: 200px;
	height: 107px;
	z-index: 7;
	left: 170px;
	top: 2034px;
}
    #apDiv8 {
	position: absolute;
	width: 618px;
	height: 33px;
	z-index: 8;
	left: 99px;
	top: 2153px;
}
    #apDiv9 {
	position: absolute;
	width: 305px;
	height: 109px;
	z-index: 9;
	left: 246px;
	top: 2198px;
}
    #apDiv10 {
	position: absolute;
	width: 727px;
	height: 41px;
	z-index: 10;
	left: 86px;
	top: 2316px;
}
    #apDiv11 {
	position: absolute;
	width: 261px;
	height: 116px;
	z-index: 11;
	left: 267px;
	top: 2369px;
}
    #apDiv12 {
	position: absolute;
	width: 710px;
	height: 84px;
	z-index: 12;
	left: 100px;
	top: 2486px;
}
    #apDiv13 {
	position: absolute;
	width: 194px;
	height: 115px;
	z-index: 13;
	left: 545px;
	top: 488px;
}
    </style>
	</head>
	<body BackGround="f22.png">
	<link href="base.css" rel="stylesheet" type="text/css">
		<span style="font-family: calibri; color: white; font-size=130%;font-size: 125%;">
<br/>
	<ul>
	  <ul type="square">
	    <span style="font-weight:bolder;font-size:150%;color:white;"> <li>Algoritmul Bellman-Ford</li> </span><br/>
      </ul>
	</ul>
	<div id="apDiv1">
    <tab2><strong>Algoritmul Bellman-Ford</strong> rezolva problema drumurilor minime de sursa unica in cazul mai general, in care costurile arcelor pot fi negative. Fiind dat un graf orientat <sp1> G </sp1>= ( <sp1>V</sp1>, <sp1>E</sp1> ) cu functia de cost <sp1>  &#969  :  E  &#8594 </sp1> &#8477, algoritmul returneaza o valoare booleana ce indica daca exista sau nu un circuit de cost negativ, accesibil din varful sursa considerat. In cazul in care un astfel de circuit exista, algoritmul semnaleaza ca nu exisa solutie, iar daca nu exista, acesta returneaza drumurile minime si costurile corespunzatoare lor.<br/>
    <tab2>Algortmul Bellman-Ford preia numele a 2 matematicieni dintre cei care l-au conceput, Richard Bellman si Lester Ford Jr. , care l-au publicat in 1958, respectiv in 1956. Cu toate acestea, Edward F. Moore a publicat, de asemenea, acelasi agoritm in 1957 si de aceea mai este numit <strong>Algoritmul Bellman-Ford-Moore</strong>.<br/>
	<tab2>La fel ca algoritmul Dijkstra, algoritmul Bellman-Ford utilizeaza tehnica de relaxare, prin intermediul decrementarii estimarii d[<sp1>v</sp1>] a drumului minim de la sursa <sp1>s</sp1> la fiecare varf <br/><sp1>v</sp1> &#8712 <sp1>V</sp1> pana este obtinut costul adevarat <sp1>&#948;</sp1>(<sp1>s</sp1>, <sp1>v</sp1>) corespunzator unui drum minim. Algoritmul returneaza ADEVARAT daca si numai daca nu contine circuite de cost negativ accesibile din sursa.
    </div>
	<div id="apDiv2">
	<b>Bellman-Ford</b>(<sp1>G</sp1>,<sp1>s</sp1>)
	<ol>
	<li>Initializeaza-Sursa-Unica(<sp1>G, s</sp1>)</li>
	<li><strong>pentru</strong> <sp1>i &#8594 </sp1>1, n-1 <strong>executa</strong> </li>
	<li><tabal><strong>pentru</strong> fiecare arc (<sp1>u</sp1>, <sp1>v</sp1>) &#8712 <sp1>E</sp1> <strong>executa</strong></li>
	<li><tabal><tabal>Relaxeaza(<sp1>u, v, &#969</sp1>)</li>
	<li><strong>pentru</strong> fiecare arc (<sp1>u</sp1>, <sp1>v</sp1>) &#8712 <sp1>E</sp1> <strong>executa</strong></li>
	<li><tabal><strong>daca</strong> d[<sp1>v</sp1>] &gt d[<sp1>u</sp1>] + <sp1>&#969</sp1>(<sp1>u</sp1>,<sp1>v</sp1>) <strong>atunci</strong></li>
	<li><tabal><tabal><strong>returneaza</strong> FALS</li>
	<li><strong>returneaza</strong> ADEVARAT</li>
	</ol>
	</div>
	<div id="apDiv3">
	<tab2>Dupa efectuarea initializarii, algoritmul efectueza n-1 treceri prin arcele grafului. Fecare trecere este o iteratie a instructiunii <strong>pentru</strong> de pe liniile 2-4 si efectueaza relaxarea fiecarui arc o singura data. Dupa efectuarea acestor treceri, liniile 5-8 verifica existenta unui circuit de cost negativ si returneaza valoarea booleana corespunzatoare.<br/>
	<tab2>Algoritmul Bellman-Ford este de o complexitate temporala <sp1>O</sp1>(n,m) unde n = |<sp1>V</sp1>| (cardinalul multimii <sp1>V</sp1>) si m = |<sp1>E</sp1>|; deoarece initializarea de pe linia1 necesita timp <sp1>O</sp1>(n), fiecare dintre cele n-1 treceri de pe liniile 2-4 necesita un timp <sp1>O</sp1>(m), iar instructiunea <strong>pentru</strong> se realizeaza tot intr-un timp de <sp1>O</sp1>(m).<br/>
	<tab2>Pentru demonstrarea corectitudinii algoritmului, incepem prin a arata ca daca nu exista ciluri de cost negativ, atunci algoritmul determina costurile corecte corespunzatoare drumurlor minime pentru toate varfurile care pot fi atinse din sursa. Demosntratia teoremei urmatoare aduce argumentul de ordin intuitiv pe care este bazat <tab8>acest algoritm. 
    </div>
	<div id="apDiv4">
    <ol>
	<li>
	<strong>Teorema 6</strong><br/>
	Fie un graf orientat <sp1> G </sp1>= ( <sp1>V</sp1>, <sp1>E</sp1> ) cu sursa <sp1>s</sp1> &#8712 <sp1>V </sp1>, functia de cost <sp1>  &#969  :  E  &#8594 </sp1> &#8477 si presupunem ca<sp1> G </sp1> nu contine circuite de cost negativ care sa pot fi atinse din <sp1>s</sp1>.In aceste conditii, la terminarea calculului initiat de <b>Bellman-Ford</b>(<sp1>G</sp1>,<sp1>s</sp1>) avem d[<sp1>v</sp1>] = <sp1>&#948;</sp1>(<sp1>s</sp1>, <sp1>v</sp1>) pentru toate varfurile <sp1>v</sp1> accesibile din <sp1>s</sp1>.<br/>
	<strong>Demonstratie</strong><br/>
	Fie <sp1>v</sp1> un nod care poate di atins din <sp1>s</sp1> si <sp1>p = &lt; v<sub>1</sub> , v<sub>2</sub> , ... , v<sub>k</sub> &gt;</sp1> un drum minim, unde <sp1>s</sp1> = <sp1>v<sub>1</sub></sp1> si <sp1>v</sp1> = <sp1>v<sub>k</sub></sp1> (k &#8804 n-1).Demonstram prin inductie ca pentru a i-a trecere prin arcele lui <sp1>G</sp1>, <br/>i = 0, 1, ..., k, avem d[<sp1>v<sub>i</sub></sp1>] = <sp1>&#948;</sp1>(<sp1>s</sp1>, <sp1>v<sub>i</sub></sp1>
	) si aceasta egalitate se pastreaza in toate momentele de timp ulterioare. Deoarece numarul total de treceri este n-1, stabilirea acestei proprietati este suficienta pentru demonstratie. Dupa initializare, avem d[<sp1>v<sub>0</sub></sp1>] = <sp1>&#948;</sp1>(<sp1>s</sp1>, <sp1>v<sub>0</sub></sp1>) = 0 si prin <strong>Teorema 3</strong> egalitatea se mentine in toate momentele ulterioare de timp. Pentru demonstrarea pasului inductiv, presupunem ca dupa cea de-a (i-1) - a trecere <br/>d[<sp1>v<sub>i-1</sub></sp1>] = <sp1>&#948;</sp1>(<sp1>s</sp1>, <sp1>v<sub>i-1</sub></sp1>). Arcul (<sp1>v<sub>i-1</sub></sp1>, <sp1>v<sub>i</sub></sp1>) este relaxat la cea de-a i-a trecere, deci prin <strong>Teorema 4</strong> rezulta d[<sp1>v<sub>i</sub></sp1>] = <sp1>&#948;</sp1>(<sp1>s</sp1>, <sp1>v<sub>i</sub></sp1>) si egaltatea se pastreaza pentru toate momentele ulterioare de timp, ceea ce incheie demonstratia.</li>
	<li>
	<strong>Corolarul Teoremei 6</strong><br/>
	Fie un graf orientat <sp1> G </sp1>= ( <sp1>V</sp1>, <sp1>E</sp1> ) cu sursa <sp1>s</sp1> &#8712 <sp1>V </sp1>, functia de cost <sp1>  &#969  :  E  &#8594 </sp1> &#8477. Atunci pentru fiecare varf <sp1>v</sp1> &#8712 <sp1>V</sp1>, exista un drum de la <sp1>s</sp1> la <sp1>v</sp1> daca si numai daca prin aplicarea algoritmului Bellman-Ford asupra grafului <sp1>G</sp1>, la terminare avem d[<sp1>v</sp1>] &lt &#8734.
	</li>
	<li>
	<strong>Teorema 7</strong>(Corectitudinea algoritmului Bellman-Ford)<br/>
	Presupunem ca algoritmul Bellman-Ford este applicat grafului orientat <sp1>G</sp1> = ( <sp1>V</sp1>, <sp1>E</sp1> ) cu varful sursa <sp1>s</sp1> &#8712 <sp1>V </sp1>, functia de cost <sp1>  &#969  :  E  &#8594 </sp1> &#8477. Daca <sp1>G</sp1> contine cel putin un circuit de cost negativ accesibil din <sp1>s</sp1>, atunci algoritmul returneaza FALS.<br/>
	<strong>Demonstratie</strong><br/>
	Presupunem ca graful <sp1> G </sp1>  contine un circuit <sp1>c</sp1> =  &lt <sp1>v<sub>1</sub></sp1>, <sp1>v<sub>2</sub></sp1>, ..., <sp1>v<sub>k</sub></sp1> &gt de cost negativ, accesibil din sursa <sp1>s</sp1>, unde <sp1>v<sub>0</sub></sp1> = <sp1>v<sub>k</sub></sp1>. Atunci:
	</li>
	</ol>
    </div>
	<div id="apDiv5"><img src="ec31.png" width="245" height="100">
    </div>
	<div id="apDiv6">
    <tab2>Sa presupunem prin absurd ca algoritmul returneaza ADEVARAT. Atunci pentru<br/>i = 1, 2, ..., k-1 rezulta d[<sp1>v<sub>i+1</sub></sp1>] &#8804  d[<sp1>v<sub>i</sub></sp1>] + <sp1>&#969</sp1>(<sp1>v<sub>i</sub></sp1>, <sp1>v<sub>i+1</sub></sp1>); deci daca insumam aceste relatii de-a lungul circuitului <sp1>c</sp1>, obtinem: 
    </div>
	<div id="apDiv7"><img src="ec32.png" width="513" height="100">
    </div>
	<div id="apDiv8">
    <tab2>Dar fiecare varf din <sp1>c</sp1> apare o singura data, deci 
    </div>
	<div id="apDiv9"><img src="ec33.png" width="295" height="100">
    </div>
	<div id="apDiv10">
    <tab2>Din moment ce, prin <strong>Corolarul Teoremei  6</strong>, d[<sp1>v<sub>i</sub></sp1>] este finita pentru i = 1, 2, ..., k-1 rezulta:
    </div>
	<div id="apDiv11"><img src="ec34.png" width="256" height="106">
    </div>
	<div id="apDiv12">
    <tab2>Ceea ce contrazice prima inegalitate. In concluzie algoritmul Bellman-Ford returneaza ADEVARAT daca graful <sp1>G</sp1> nu contine circuite de cost negativ accesibile din sursa <sp1>s</sp1> si FALS in caz contrar.
    </div>
	</span>
	<div id="menup">
	<ul>
	<li><a href="not32.html" target="desk">Previous</a></li>
	</ul>
	</div>
	<div id="menun">
	<ul>
	<li><a href="not34.html" target="desk">Next</a></li>
	</ul>
	</div>
    <div id="apDiv13"><img src="Richard_Ernest_Bellman.jpg" width="184" height="230"></div>
</body>
</html>